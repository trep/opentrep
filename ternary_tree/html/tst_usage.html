<html>
    <head>
      <title>Ternary Tree: Examples</title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
<style>
/* must override a few items to get the style background color */
HR { background-color: #e09060; }
..memproto {
  background-color: #fbf8d0; 
  border-color: #e09060;
}
</style>
    </head>
    <body>
<table width="100%" style="font-weight: bold; background-color: #fbf8d0; padding: 0.3em;"><tr><td>
<a style="text-decoration: none;" href="index.html">Overview</a>&nbsp;&nbsp;&nbsp;&nbsp;
<!--a style="text-decoration: none;" href="classcontainers_1_1ternary__tree.html">Ternary Search Tree</a >&nbsp;&nbsp;&nbsp;&nbsp;-->
<a style="text-decoration: none;" href="tst_usage.html">Usage</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a style="text-decoration: none;" href="perf_notes.html">Performance Notes</a>&nbsp;&nbsp;&nbsp;&nbsp;
<!--a style="text-decoration: none;" href="tst_impl.html">Implementation Details</a>&nbsp;&nbsp;&nbsp;&nbsp;-->
<a style="text-decoration: none;" href="tst_links.html">Links</a></td>
<td align="right" style="font-weight: normal; font-style: italic; color: #606080;">tst 0.68 - 23 Jan 2009</td>
</tr></table>
<hr style="height: 3px;">
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="tst_usage">Examples </a></h1><center></center><p>
<center><table bgcolor="#fbf9e5" style="border: thin dotted rgb(128, 128, 0);" width="95%" border="0" cellspacing="3" cellpadding="3">
<tr>
<td><h3>Table of contents</h3>
<p>
<dl>
<dt><a class="el" href="tst_usage.html#usage_basic">Basic use</a> </dt>
<dd></dd>
<dt><a class="el" href="tst_usage.html#usage_searches">Advanced searches</a> </dt>
<dd><a class="el" href="tst_usage.html#usage_longest_match">longest_match - tokenizer</a> <br>
 <a class="el" href="tst_usage.html#usage_search_results">search_results_list - pseudo vector&lt;StructuredContainer::iterator&gt;</a> <br>
 <a class="el" href="tst_usage.html#usage_imprecise_searches">Imprecise searches overview</a> <br>
 <a class="el" href="tst_usage.html#usage_scrabble_search">Combinatorial (or "scrabble") lookup: all words using these chars</a>  </dd>
<dt><a class="el" href="tst_usage.html#usage_custom_comp">Custom comparators</a> </dt>
<dd></dd>
<dt><a class="el" href="tst_usage.html#usage_localize">Localization comparator</a> </dt>
<dd></dd>
<dt><a class="el" href="tst_usage.html#usage_ternary_tree">The ternary_tree backend class</a> </dt>
<dd></dd>
</dl>
</td></tr>
</table>
</center><p>
<hr>
<h2><a class="anchor" name="usage_basic">
Basic use</a></h2>
The best and simplest way to use the Ternary Search Tree-backed <a class="el" href="namespacecontainers.html">containers</a> is to select the appropriate structured_[set, map, multiset or multimap] container, and use it just like its STL counterpart.<p>
<b>Note:</b> in these usage notes we will not explain the behaviour of standard set, map or unordered_* <a class="el" href="namespacecontainers.html">containers</a>. Please look at documentation and examples for your standard library associative <a class="el" href="namespacecontainers.html">containers</a>, and please double-check the structured_* container reference when in doubt.<p>
The class methods are exactly the same as for (multi)set and (multi)map, and show the same behaviour (except usually quite a bit faster). The only difference is the template definition, and this only becomes apparent if you want to use a custom comparator type. Then of course there are the advanced search methods. That's the good bit, we'll get to them shortly.<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// Basic use of structured_set</span>
<span class="comment">//</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include "<a class="code" href="structured__set_8hpp.html">structured_set.hpp</a>"</span>

<span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1structured__set.html" title="Structured Set is a Sorted Associative Container that stores objects of type Key...">containers::structured_set&lt;std::string&gt;</a> Set;
<span class="keyword">typedef</span> Set::iterator SetIter;
<span class="keyword">typedef</span> std::pair&lt;SetIter, SetIter&gt; IterPair;

<span class="comment">// Insert some keys</span>
names.insert(<span class="stringliteral">"apps"</span>);
names.insert(<span class="stringliteral">"applets"</span>);
names.insert(<span class="stringliteral">"banana"</span>);

std::cout &lt;&lt; <span class="stringliteral">"The set contains\n    "</span>;
<span class="keywordflow">for</span> (SetIter it = names.begin(); it != names.end(); ++it)
    std::cout &lt;&lt; *it &lt;&lt; <span class="stringliteral">", "</span>;
</pre></div> This should print <div class="fragment"><pre class="fragment">The <span class="keyword">set</span> contains
    applets, apps, banana, 
</pre></div><p>
A simple search: <div class="fragment"><pre class="fragment">IterPair p = names.prefix_range(<span class="stringliteral">"app"</span>);
std::cout &lt;&lt; <span class="stringliteral">"prefix_range(\"app\") returns:\n  "</span>;
<span class="keywordflow">while</span> (p.first != p.second) {
    std::cout &lt;&lt; *p.first++ &lt;&lt; <span class="stringliteral">", "</span>;
}
</pre></div> prints <div class="fragment"><pre class="fragment">prefix_range(<span class="stringliteral">"app"</span>) returns:
    applets, apps,
</pre></div> and <code>p.second</code> points to "banana".<p>
In contrast, the standard set/map operation <code>equal_range</code> would return a pair of <a class="el" href="namespaceiterators.html">iterators</a> pointing to the same item: <div class="fragment"><pre class="fragment">std::cout &lt;&lt; <span class="stringliteral">"equal_range(\"app\") returns "</span>;
p = names.equal_range(<span class="stringliteral">"app"</span>);
<span class="keywordflow">if</span> (p.first == p.second)
    std::cout &lt;&lt; <span class="stringliteral">"empty range\n"</span>;
std::cout &lt;&lt; <span class="stringliteral">"p.second points to "</span> &lt;&lt; *p.second;
</pre></div><p>
This prints <div class="fragment"><pre class="fragment">equal_range(<span class="stringliteral">"app"</span>) returns empty range
p.second points to applets
</pre></div> (So equal_range points to the place where "app" would be inserted.)<p>
In short, this section shows that if you have used <code>std::set</code>, you already have code to use <code>structured_set</code>.<p>
<hr>
 <h2><a class="anchor" name="usage_searches">
Advanced searches</a></h2>
Now we get to the good stuff.<p>
Currently structured <a class="el" href="namespacecontainers.html">containers</a> provide two useful single-key search methods returning iterator(s), and four different searches that return a list of matches. We begin with the "single-key" methods.<p>
<h3>prefix_range</h3>
<p>
We have already seen <a class="el" href="classcontainers_1_1ternary__tree.html#d3a2e52c87d13662bfc39c58e047a3b2">prefix_range</a>, which returns a range of keys that share the search string as prefix. If you use a structured container to store symbols found by a parser, a typical application of <code>prefix_range</code> might be to find all names of class members, or all names in a name scope. Names might be stored like many C++ parsers (eg like <code>"::scope1::scopeN::classname&lt;neverending_list_of_types&gt;::membername"</code>), or dot-separated like javascript or many other languages: <code>"class.innerclass.member"</code>. <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1structured__set.html" title="Structured Set is a Sorted Associative Container that stores objects of type Key...">containers::structured_set&lt;std::string&gt;</a> SymbolSet;
SymbolSet symbols;
<span class="keywordtype">bool</span> is_defined_in_scope(std::string scope, std::string name)
{
    <span class="keyword">typedef</span> std::pair&lt;SymbolSet::iterator, SymbolSet::iterator&gt; Range;
    Range r = symbols.prefix_range(scope);
    SymbolSet::iterator n = symbols.find(name);
    <span class="keywordflow">return</span> n != symbols.end() &amp;&amp; *n &gt;= *r.first &amp;&amp; *n &lt; *r.second;
}
</pre></div><p>
Here the glory is soiled by not having random access <a class="el" href="namespaceiterators.html">iterators</a>. We cannot compare the <a class="el" href="namespaceiterators.html">iterators</a> (in constant time) to find their order, instead we have to dereference and compare the keys. (and the reason we cannot just compare the scope and the name strings is not apparent from the above code sketch)<p>
<hr>
<h3><a class="anchor" name="usage_longest_match">
longest_match - tokenizer</a></h3>
<a class="el" href="classcontainers_1_1ternary__tree.html#63252eb2273c6824f50894652b99ed86">longest_match</a> takes a different tack. Its arguments are two <a class="el" href="namespaceiterators.html">iterators</a> that point to a range of <code>char_type</code> (ie, some text). It then finds the longest key that can be matched to the beginning of the char range. If a key is found, it advances the first char iterator so it is positioned after the found key. This way it's easy to use a structured container as a simple tokenizer, and for large vocabularies, comparatively efficient.<p>
Here is a tokenizer over a large dictionary which is nearly as fast as a single ternary_tree.find() operation. <br>
 <b>Note that we do NOT use a <code>std::istream_iterator</code> for the input from file.</b> The <a class="el" href="namespaceiterators.html">iterators</a> passed to <code>longest_match</code> must support distance(), that is, they must be Forward Iterators, an Input Iterator is not enough.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> longest_match_example(<span class="keyword">const</span> <span class="keywordtype">char</span>* dictfile, <span class="keyword">const</span> <span class="keywordtype">char</span>* parsefile)
{
    <span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1structured__map.html" title="Structured Map is a Sorted Associative Container that stores objects of type pair&amp;lt;Key...">containers::structured_map&lt;std::string, int, nocase_less&lt;char&gt;</a> &gt; Vocabulary;
    Vocabulary english;
    <span class="comment">// Fill dictionary</span>
    fill_wordlist(dictfile, english);    <span class="comment">// (not shown here)</span>
    <span class="keywordflow">if</span> (english.empty())
        <span class="keywordflow">return</span>;

    <span class="comment">// longest_match does not work with istream_iterator, so must fill buffer</span>
    std::ifstream infile(parsefile);
    <span class="keywordtype">size_t</span> filesize = get_filesize(infile);  <span class="comment">// (not shown here)</span>
    boost::scoped_array&lt;char&gt; bytes(<span class="keyword">new</span> <span class="keywordtype">char</span>[filesize]);
    infile.read(bytes.get(), filesize);

    <span class="keywordtype">char</span> *first = bytes.get();
    <span class="keywordtype">char</span> *last = first + infile.gcount();
    <span class="keywordflow">while</span> (first != last) 
    {
        Vocabulary::iterator word = english.longest_match(first, last);
        <span class="keywordflow">if</span> (word != english.end())
            std::cout &lt;&lt; (*word).first &lt;&lt; <span class="stringliteral">" "</span>;
        <span class="keywordflow">else</span> {
            <span class="comment">// No key; try next char</span>
            ++first;
        }
    }
}
</pre></div><p>
Note that this may return spurious results if a word is not in the dictionary. Tokenizing Shakespeare quotes over the English Scrabble dictionary may return <div class="fragment"><pre class="fragment"> <span class="stringliteral">"there"</span> <span class="stringliteral">"is"</span> <span class="stringliteral">"something"</span> <span class="stringliteral">"rotten"</span> <span class="stringliteral">"in"</span> <span class="stringliteral">"den"</span> <span class="stringliteral">"mark"</span> 
</pre></div> since "Denmark" is a proper name (and so not allowed in the Scrabble game).<p>
<hr>
 <h3><a class="anchor" name="usage_imprecise_searches">
Imprecise searches overview</a></h3>
We have three degrees of imprecision to choose from in this ternary tree implementation:<ul>
<li>Search with wildcards: letters in specific position of the search string may mismatch (<code>partial_match_search</code>).</li><li>A limited number of letters in any position may mismatch. The count of mismatches is called the Hamming distance, so finding all strings within a certain distance is called a <code>hamming_search</code>.</li><li>Some letters may mismatch, and some may also be inserted between chars in the search string, or letters of the search string may be skipped. The differences can be viewed as "edit operations," and the count of edits are technically known as the Levenshtein distance. Hence, the <code>levenshtein_search</code> (which could use a more descriptive name).</li></ul>
<p>
The functions have similar interface: Arguments are the search-string, an output iterator onto which the results are assigned, and a search configuration parameter. For the partial match, the configuration is the wildcard character used in the search string (by default '?'), for Hamming and Levenshtein searches it is the number of allowed mismatches/edits. Here are the function call prototypes:<ul>
<li><code>OutputIter <a class="el" href="classcontainers_1_1ternary__tree.html#8c63d4ad36f66355803cfcedec5f61ad">partial_match_search</a> (const key_type&amp; , OutputIter , char_type wildcard = '?');</code></li><li><code>OutputIter <a class="el" href="classcontainers_1_1ternary__tree.html#271002d995ff11ea86157acfbbb32c70">hamming_search</a> (const key_type&amp; , OutputIter , size_type dist);</code></li><li><code>OutputIter <a class="el" href="classcontainers_1_1ternary__tree.html#1a065731747766b371dbc8b2dd13a5ea">levenshtein_search</a> (const key_type&amp; , OutputIter , size_type dist);</code></li></ul>
<p>
<hr>
<h3><a class="anchor" name="usage_search_results">
search_results_list - pseudo vector&lt;StructuredContainer::iterator&gt;</a></h3>
The imprecise searches and the combinatorial or "scrabble" search all feed the search results to a forward iterator that accept structured container <a class="el" href="namespaceiterators.html">iterators</a>. The <code>search_results_list</code> is a wrapper class that is almost a <code>std::vector&lt;<em>StructuredContainer:</em>:</code> <code>iterator&gt;</code> but to save space we store a single reference to the tree and a list of positions. The <code>search_results_list</code> returns proper <a class="el" href="namespaceiterators.html">iterators</a> from its methods.<p>
Each <code>search_results_list</code> (abbr: SRL) is thus bound to a specific container instance. Therefore we chose to construct it by a factory method on structured <a class="el" href="namespacecontainers.html">containers</a>: <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1structured__map.html" title="Structured Map is a Sorted Associative Container that stores objects of type pair&amp;lt;Key...">containers::structured_map&lt;std::string, MyStuff&gt;</a> StuffMap;
StuffMap mystuff;
<span class="comment">// Create the search results list</span>
StuffMap::search_results_list results = mystuff.create_search_results();
</pre></div><p>
To use it with the search methods, wrap the results in a <code>std::back_iterator</code>, eg <div class="fragment"><pre class="fragment"> mystuff.levenshtein_search(key, std::back_iterator(results), 3); 
</pre></div><p>
The SRL class is defined with a template parameter for the source container iterator, so it is bound to the right iterator type.<p>
The results list class is also limited - it doesn't do all a vector could do. We define<ul>
<li>the <code>tree_iterator</code> type, which is the typename of the owner container's iterator type</li><li>push_back() so we can pass a <code><a class="el" href="classstd_1_1back__insert__iterator.html">std::back_insert_iterator</a></code> to search methods</li><li>an <code>iterator</code> type, which return tree_iterators when dereferenced</li><li><code>operator</code>[] which also returns a tree_iterator</li><li><code>size()</code>, <code>empty()</code>, <code>clear()</code> with the expected behaviour.</li></ul>
<p>
The <code>search_results_list::iterator</code> can be treated as a pointer-to-pointer: <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> StuffMap::search_results_list::iterator ResultIter;
<span class="comment">// ...</span>
<span class="keywordflow">for</span> (ResultIter it = results.begin(); it != results.end(); ++it)
    std::cout &lt;&lt; (**it).second &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div> equally you may use the subscript operator: <div class="fragment"><pre class="fragment"><span class="comment">// ...</span>
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; results.size(); ++i)
    std::cout &lt;&lt; (*results[i]).first &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; (*results[i]).second &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div><p>
and that's all there is to it. We'll put it to use in the searches coming up.<p>
<hr>
<h3><a class="anchor" name="usage_partial_match">
Wildcard lookup: partial_match_search</a></h3>
The wildcard search is easy to use for fixed patterns with some hooks - dates or ID's of any kind. The partial_match_search function accepts a search string that designates a special character as wildcard. This is by default '?', but could be anything - original DDJ authors use the dot '.' as wildcard.<p>
To find all dates, if they somehow end up as a string in a structured container, the search is simple: <div class="fragment"><pre class="fragment">search_results_list dates = mystrings.create_search_results();
mystrings.partial_match_search(<span class="stringliteral">"??/\??"</span>, std::back_iterator(results));
</pre></div><p>
The search will be more expensive the more wildcards are put in the beginning of the search key. For each wildcard, every node at that level will be inspected, ie up to the entire alphabet.<p>
For fixed patterns regexes would normally be the most useful tool, but if they are stored as strings.<p>
<hr>
<h3><a class="anchor" name="usage_levenshtein_search">
Spell-checker lookup: levenshtein_search</a></h3>
The last type of imprecise search is more complicated: it allows for keys that differ from the search string by insertions, or by skipping char(s) in the search string, or by plain mismatch. Therefore the same key may be matched in different ways. The implementation of levenshtein search has to try each available path, up to the allowed mismatch count.<p>
This search can therefore be considered expensive, since several alternative searches are performed in parallel over each node traversed. At the same time it is very powerful, and <code>dist</code> values of at most 2-3 is normally sufficient. (Put in another way: <code>dist</code> of 20-30% of search string length is usually plenty.)<p>
<b>Main advise: limit your searches</b><p>
One lesson learnt from <a class="el" href="perf_notes.html">performance tests</a> is that it is cheaper to perform several levenshtein searches with lower distance than to overshoot the distance by one. So, if you for instance just want to find any match, the way to go is to perform all searches from <code>dist=1</code> up until you get enough results to be happy.<p>
Note that a levenshtein search with <code>dist</code> = 5 on a 5-letter key will return <em>all</em> 1-, 2-, 3-, 4- and 5-letter words in the tree, plus all 6-letter keys containing at least one char from the search key, plus all 7-letter words containing at least two letters in the same order as in search key, etc etc. <br>
 See the count of found keys for different searches in the second table in <a class="el" href="perf_notes.html">Performance Notes</a>.<p>
So, normally the <code>dist</code> count should be kept low. It may often be optimal to perform several searches, increasing the <code>dist</code> count only if no matches are found.<p>
<hr>
 <h3><a class="anchor" name="usage_scrabble_search">
Combinatorial (or "scrabble") lookup: all words using these chars</a></h3>
<hr>
 <h2><a class="anchor" name="usage_custom_comp">
Custom comparators</a></h2>
The behaviour of structured <a class="el" href="namespacecontainers.html">containers</a> can be modified by a custom comparator. Unlike the standard set, map <a class="el" href="namespacecontainers.html">containers</a>, the comparator works on single characters. Here we define a case-insensitive structured_multiset. The comparator is simple: <div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// Case-insensitive structured containers</span>
<span class="comment">//</span>
<span class="preprocessor">#include &lt;functional&gt;</span>

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharT&gt;
<span class="keyword">struct </span>nocase_less : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1binary__function.html">binary_function</a>&lt;CharT, CharT, bool&gt;
{
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> CharT&amp; a, <span class="keyword">const</span> CharT&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> tolower(a) &lt; tolower(b); }
};

<span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1structured__multiset.html" title="Structured Multiset is a Sorted Associative Container that stores objects of type...">containers::structured_multiset&lt;std::string, nocase_less&lt;char&gt;</a> &gt; CaselessSet;
</pre></div><p>
It will store all capitalisation variants of a key under the same key, but returns the exact inserted strings. <div class="fragment"><pre class="fragment">CaselessSet caseless;
caseless.insert(<span class="stringliteral">"NoCase"</span>);
caseless.insert(<span class="stringliteral">"nocase"</span>);
caseless.insert(<span class="stringliteral">"noCase"</span>);
caseless.insert(<span class="stringliteral">"NOCASE"</span>);

std::cout &lt;&lt; <span class="stringliteral">"nocase count: "</span> &lt;&lt; caseless.count(<span class="stringliteral">"nocase"</span>);

<span class="keywordflow">for</span>(CaselessSet::iterator it = caseless.begin(); it != caseless.end(); ++it) {
    std::cout &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; *it;
}
</pre></div> This prints <div class="fragment"><pre class="fragment"> nocase count: 4, NoCase, nocase, noCase, NOCASE 
</pre></div> - so the names are stored in insertion order, not in sort order. If we used a unique structured_set, only the first would have been stored, "NoCase".<p>
We are not doing anything here that couldn't be done with std::multiset, though the comparator would look different. But we are doing it 3-4 times faster!<p>
<hr>
 <h2><a class="anchor" name="usage_localize">
Localization comparator</a></h2>
Now imagine that you want your non-English dictionary properly sorted. The Swedish alphabet ends with the letters<ul>
<li>A-ring: <b>&Aring;</b>, <b>&aring;</b> </li><li>A-umlaut: <b>&Auml;</b>, <b>&auml;</b> </li><li>O-umlaut: <b>&Ouml;</b>, <b>&ouml;</b> </li></ul>
<p>
The Latin-1 character table (ISO-8859-1) graciously includes even the weird A-ring letter (an A with a small ring on top, perhaps not even representable in your browser). So we're lucky. But, it doesn't store them in the local sort order. Nor does it use the Danish and Norwegian sort order: Æ (AE), &Oslash;, &Aring;.<p>
So we need another custom comparator here. It is again a <code>std::binary_function&lt;CharT, CharT, bool&gt;</code> type - and you can probably figure out how to do it by using <code>std::locale's</code> facet <code>collate::compare</code> for char-by-char comparison. (We'll do better in a minute though.): <div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;locale&gt;</span><span class="comment"></span>
<span class="comment">//! Expensive single-character comparison by std::locale&lt;&gt; facet collate</span>
<span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> CharT&gt;
<span class="keyword">struct </span>collate_comp : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1binary__function.html">binary_function</a>&lt;CharT, CharT, bool&gt;
{
    collate_comp(<span class="keyword">const</span> std::string&amp; name) : m_locale(name.c_str()) {}

    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> CharT&amp; a, <span class="keyword">const</span> CharT&amp; b)<span class="keyword"> const </span>{
        <span class="keyword">const</span> CharT * a0 = &amp;a, *b0 = &amp;b;
        <span class="keywordflow">return</span> std::use_facet&lt;std::collate&lt;CharT&gt; &gt;(m_locale).compare(a0, a0+1, b0, b0+1) &lt; 0;
    }

<span class="keyword">private</span>:
    std::locale m_locale;
};
</pre></div><p>
Provided we have this, just supply the type at the Compare template parameter to your structured container. This comparator needs to know which locale to use, so this must be passed to the container constructor: <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1structured__set.html" title="Structured Set is a Sorted Associative Container that stores objects of type Key...">containers::structured_set&lt;std::string, collate_comp&lt;char&gt;</a> &gt; LocalSet;

<span class="comment">// use comparator constructor, create Swedish locale</span>
LocalSet se_names(collate_comp&lt;char&gt;(<span class="stringliteral">"sv_SE"</span>));

<span class="comment">// Use a default comparator for contrast</span>
<span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1structured__set.html" title="Structured Set is a Sorted Associative Container that stores objects of type Key...">containers::structured_set&lt;std::string&gt;</a> DefaultSet;
DefaultSet anynames;
</pre></div><p>
Try it with some Swedish words: <div class="fragment"><pre class="fragment">se_names.insert(<span class="stringliteral">"Äska"</span>);
se_names.insert(<span class="stringliteral">"Åmål"</span>);
se_names.insert(<span class="stringliteral">"Ödla"</span>);
se_names.insert(<span class="stringliteral">"Adam"</span>);

anynames.insert(<span class="stringliteral">"Äska"</span>);
anynames.insert(<span class="stringliteral">"Åmål"</span>);
anynames.insert(<span class="stringliteral">"Ödla"</span>);
anynames.insert(<span class="stringliteral">"Adam"</span>);

 
<span class="keywordflow">for</span>(LocalSet::iterator sit = se_names.begin(); sit != se_names.end(); ++sit) {
    std::cout &lt;&lt; *sit &lt;&lt; <span class="stringliteral">", "</span>;
}
std::cout &lt;&lt; <span class="stringliteral">"not:\n"</span>
<span class="keywordflow">for</span>(DefaultSet::iterator dit = anynames.begin(); dit != anynames.end(); ++dit) {
    std::cout &lt;&lt; *dit &lt;&lt; <span class="stringliteral">", "</span>;
}
</pre></div> prints <div class="fragment"><pre class="fragment"> Adam, Åmål, Äska, Ödla, not:
 Äska, Ödla, Åmål, Adam, 
</pre></div><p>
Well, actually it doesn't for me, it prints something horrible to my console, since I didn't set the locale for the DOS console window. But the horrors are correctly sorted anyway.<p>
Unfortunately the <code>std::collate</code> comparison comes at a cost: In the STL implementation I use (STLport) there is a virtual function call that ends up in a system or library function for every character comparison (on Windows we go to CompareString API). This is a major hit on performance; now <code>find</code> is about 50-100 times slower than using the default <code>less&lt;char&gt;</code> comparator! A std::map with a similar locale-based comparator is also slowed down, but "only" about 8-10 times. So now std::map is 2-4 times faster than structured <a class="el" href="namespacecontainers.html">containers</a>.<p>
To get around this, we can create an alphabet-size sort-order table using locale, then do character comparison through table lookup. The full <code>wchar_t</code> table requires 2^16 X 2 = 128 kB storage. Your system may already provide similar technology under the hood. The file <a href="../examples/locale_less.hpp">examples/locale_less.hpp</a> has a class <code>utility::locale_less&lt;CharT&gt;</code> which does this.<p>
A quick test of the perfomance of this table-lookup solution indicates it is about 2 times slower than ternary_tree with default comparator. This is a modest price to pay for internationalization.<p>
The better type declaration looks almost the same as above: <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "examples/locale_less.hpp"</span>

<span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1structured__set.html" title="Structured Set is a Sorted Associative Container that stores objects of type Key...">containers::structured_set&lt; std::string, utility::locale_less&lt;char&gt;</a> &gt; LocalSet;

<span class="comment">// use comparator constructor, create Swedish locale</span>
LocalSet se_names(utility::locale_less&lt;char&gt;(<span class="stringliteral">"sv_SE"</span>));
    
<span class="comment">//... etc</span>
</pre></div><p>
By the way, if you want the locale-table optimization for a <code>std::map&lt;string, Key&gt;</code>, why not use the <a class="el" href="classcontainers_1_1structured__set.html#8e71047e246d12f3e85e0ddb12863a3f">structured_set::key_compare</a> type from LocalSet above! It's a simple <code>lexicographical_compare</code> using the <code>utility::locale_less</code> class. It's faster than raw <code>std::collate::compare</code> calls anyway. Just a thought.<p>
<hr>
 <h2><a class="anchor" name="usage_ternary_tree">
The ternary_tree backend class</a></h2>
The <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree&lt;Key, Value, Comp, Alloc&gt;</a> class interface is sufficiently similar to the more standard-like <a class="el" href="namespacecontainers.html">containers</a> that it should be easy to use, but some special quirks must be noted.<p>
<ol type=1>
<li><a class="el" href="namespaceiterators.html">iterators</a> are non-standard</li><li>two macros are used to configure tree</li></ol>
<p>
First off, although <code>ternary_tree</code> is Associative and stores both a Key and Value, it is NOT Pair Associative (like <code>std::set</code> and <code>map</code> etc). <br>
 Therefore, for a <code>ternary_tree&lt;std::string, int&gt;</code> <ul>
<li><code>value_type</code> is the <code>Value</code> template parameter, ie <b>int</b> </li><li><code>reference</code> is <code>int&amp;</code>, <code>const_reference</code> is <code>int const&amp;</code></li><li>Default allocator is <code>std::allocator&lt;Value&gt;</code>, ie <code>std::allocator&lt;int&gt;</code> </li><li>Default comparator is <code>less&lt;char&gt;</code> (like all structured <a class="el" href="namespacecontainers.html">containers</a>)</li></ul>
<p>
Consequently, iterator <code>value_type</code> is <code>int</code>, and iterator dereference returns (const) <code>int&amp;</code> <br>
 More about this next.<p>
<hr>
 <h3><a class="anchor" name="usage_tst_iterator">
ternary_tree::iterator type</a></h3>
Due to the restrictions on <a class="el" href="namespaceiterators.html">iterators</a> for Pair Associative <a class="el" href="namespacecontainers.html">containers</a> (they must be <code>pair&lt;Key, Value&gt;</code>), and the internals of ternary_tree, the <a class="el" href="namespaceiterators.html">iterators</a> are non-standard. Various designs for proxy class were attempted, but this only makes the code deceptive, it doesn't supply expected behaviour.<p>
Therefore the ternary tree iterator dereference does NOT return a pair, it returns the <code>value_type</code> as defined in the template.<p>
It is still necessary to get the key for an iterator. For this purpose a member method <code>key()</code> is defined on the iterator. To complement this, the method value() returns a reference to the value. Here is brief reference of the type defined as iterator for ternary tree: <div class="fragment"><pre class="fragment">key_type <span class="keyword">const</span>&amp;  key() <span class="keyword">const</span>;
const_reference  value() <span class="keyword">const</span>;
node_index tree_position() <span class="keyword">const</span>;  <span class="comment">// used by wrapper classes</span>

reference       operator*();       <span class="comment">// available with nonconst_traits only</span>
const_reference operator*() <span class="keyword">const</span>;
<span class="comment">// ... bidirectional iterator like operator++, operator-- etc</span>
</pre></div><p>
Please be warned that the key reference returned is NOT PERSISTENT: the key is cached in iterator, so when the iterator is incremented or decremented, the key is changed internally. So don't try to keep the reference, copy it at each access. <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <a class="code" href="classcontainers_1_1ternary__tree.html" title="Ternary search tree (trie) is a sorted container for strings, with advanced search...">containers::ternary_tree&lt;std::string, int&gt;</a> MyTst;
MyTst tst;  
<span class="comment">// ...fill tree</span>
MyTst::iterator it = tst.find(<span class="stringliteral">"global"</span>);
MyTst::key_type&amp; temp = it.key();  <span class="comment">// WRONG!</span>
std::string temp2 = it.key();      <span class="comment">// Better</span>
it++;                 <span class="comment">// temp is changed now</span>
</pre></div><p>
The typedef to get this interface uses two wrapper layers as detailed below.<p>
<hr>
 <h3><a class="anchor" name="macro_tst_no_standalone_iterator_facade">
Macro TST_NO_STANDALONE_ITERATOR_FACADE</a></h3>
<b>Where:</b> <a class="el" href="ternary__tree_8hpp.html" title="Conversion to C++ of the DDJ article code by Jon Bentley and Robert Sedgewick.">ternary_tree.hpp</a>, <a class="el" href="tst__iterator__facade_8hpp.html">tst_detail/tst_iterator_facade.hpp</a><p>
<b>Define:</b> When you write a container using ternary_tree for implementation. <br>
 <b>Don't define:</b> when you use ternary_tree directly in application code.<p>
ternary_tree uses an internal class <a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html"><code>tst_iterator_base</code> </a>with methods <code>dereference()</code>, <code>increment()</code>, <code>decrement()</code> etc for basic iterator support. There are also a few methods useful for wrapper classes like structured_set &amp;co.<p>
To provide standard iterator interface we use the <a class="el" href="structiterators_1_1iterator__wrapper.html">iterator_wrapper</a> adapter. As noted above, the iterator base class provides some methods useful in client code (esp <code>key()</code>). The typedef so far is just: <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> iterator_wrapper&lt; tst_iterator_base, const_traits&lt;value_type&gt; &gt;    const_iterator;
<span class="keyword">typedef</span> iterator_wrapper&lt; tst_iterator_base, nonconst_traits&lt;value_type&gt; &gt; iterator;
</pre></div> (namespaces omitted to simplify)<p>
In client code, the base iterator methods has to be accessed like <code>myTstIter.<b>base_iter()</b>.key()</code> etc, which quickly gets tedious.<p>
Therefore we also provide another wrapper layer: <a class="el" href="structcontainers_1_1tst__detail_1_1iter__method__forward.html"><code>tst_detail</code>::iter_method_forward</a>. This forwards the base iterator methods, so client code can use directly without inserting <code>base_iter()</code> everywhere. Yes, it's a mess and backwards, but we'll change to use Boost.Iterator in the future.<p>
But structured container wrappers don't need this forwarding, thus the macro to avoid the <code>iter_method_forward</code> complications.<p>
<hr>
 <h3><a class="anchor" name="macro_tst_use_fastmap">
Macro TST_USE_FASTMAP (deprecated)</a></h3>
<b>Where:</b> <a class="el" href="ternary__tree_8hpp.html" title="Conversion to C++ of the DDJ article code by Jon Bentley and Robert Sedgewick.">ternary_tree.hpp</a>, tst_detail/ternary_tree_impl.ipp<p>
<b>Define:</b> If you want to experiment with fastmap. <br>
 <b>Usage:</b> Define before including the library header file (<a class="el" href="ternary__tree_8hpp.html" title="Conversion to C++ of the DDJ article code by Jon Bentley and Robert Sedgewick.">ternary_tree.hpp</a>, <a class="el" href="structured__set_8hpp.html">structured_set.hpp</a> etc)<p>
Note that the macro is undefined at end of <a class="el" href="ternary__tree_8hpp.html" title="Conversion to C++ of the DDJ article code by Jon Bentley and Robert Sedgewick.">ternary_tree.hpp</a> header.<p>
We have experimented with a fastmap, ie a alphabet-size array of pointers to the node for the first letter of a key. When this macro is defined, the fastmap is installed and maintained by insertion (but <b>not</b> by erase!)<p>
For ex, to look up "shortcut", the <a class="el" href="classcontainers_1_1ternary__tree.html#554fff911aa25bba58d1685c5aa68832">find_impl</a> method doesn't begin at root, instead it starts at <code>fastmap['s']</code>. This turns out to give insignificant improvement for ASCII dictionaries: While there is a weak improvement of lookup times, it's rarely over 3-5%, usually less than time jitter of the test runs. For unbalanced (sorted-insertion) trees, insert() is over 10% faster (improving as the tree grows).<p>
With <code>wchar_t</code> and a large alphabet, it might be useful.<p>
It might be useful to provide fastmap of the 2 first characters. This is not tested, as it would be complex to code. Also with the future subkey_iterator type, it will be easy to build a fastmap in client code, eg a vector of subkey_iterators. So this macro will probably be removed (still it adds only half a dozen lines total). </div>
<hr style="height: 3px; border-top: 0px; background-color: #e09060;">
<table width="100%"><tr style="color: #606080; font-size: 90%;" border="0">
<td><em>ternary_tree 0.68 -- by rasmus ekman
-- Page generated with <a href="http://doxygen.org">Doxygen 1.5.6</a> on 23 Jan 2009</em></td>
<td style="text-align: right; color:#f0f0ff;"><!--#exec cgi="/cgi-bin/counter"--></td>
</tr></table>
</body>
</html>
